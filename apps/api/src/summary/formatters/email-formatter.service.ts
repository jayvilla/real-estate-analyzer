import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { EmailReport, SummaryFormat } from '@real-estate-analyzer/types';
import { StructuredLoggerService } from '../../common/logging/structured-logger.service';
import { TemplateService } from '../templates/template.service';

/**
 * Email Formatter Service
 * Note: This is a placeholder implementation.
 * For production, install and use nodemailer:
 * npm install nodemailer @types/nodemailer
 */
@Injectable()
export class EmailFormatterService {
  constructor(
    private readonly templateService: TemplateService,
    private readonly configService: ConfigService,
    private readonly logger: StructuredLoggerService
  ) {}

  /**
   * Generate email report from summary
   */
  async generateEmailReport(
    summary: any,
    recipients: string[],
    subject?: string
  ): Promise<EmailReport> {
    // Override recipients in dev/local environments
    const actualRecipients = this.getActualRecipients(recipients);

    // Get HTML template
    const template = this.templateService.getTemplates(
      summary.type,
      SummaryFormat.HTML,
      summary.language
    )[0];

    let html = '';
    if (template) {
      html = this.templateService.renderTemplate(template, summary);
    } else {
      html = this.generateDefaultHTML(summary);
    }

    // Generate text version
    const text = this.generateTextVersion(summary);

    return {
      to: actualRecipients,
      subject: subject || this.generateSubject(summary),
      html: this.wrapInEmailTemplate(html),
      text,
    };
  }

  /**
   * Get actual recipients based on environment
   * In dev/local, redirect all emails to test email
   */
  private getActualRecipients(originalRecipients: string[]): string[] {
    const env = this.configService.get<string>('NODE_ENV', 'development');
    const testEmail = this.configService.get<string>('TEST_EMAIL');

    // In development/local, redirect to test email if configured
    if ((env === 'development' || env === 'local') && testEmail) {
      this.logger.logWithMetadata(
        'info',
        `Email redirected to test address in ${env} environment`,
        {
          originalRecipients,
          testEmail,
        },
        'EmailFormatterService'
      );
      return [testEmail];
    }

    return originalRecipients;
  }

  /**
   * Generate default HTML from summary
   */
  private generateDefaultHTML(summary: any): string {
    let html = '<div style="font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto;">';

    if (summary.overview) {
      html += `<h1>Summary</h1><p>${summary.overview}</p>`;
    }

    if (summary.keyMetrics) {
      html += '<h2>Key Metrics</h2><ul>';
      summary.keyMetrics.forEach((metric: any) => {
        html += `<li><strong>${metric.label}:</strong> ${metric.value}</li>`;
      });
      html += '</ul>';
    }

    if (summary.recommendations) {
      html += '<h2>Recommendations</h2><ul>';
      summary.recommendations.forEach((rec: string) => {
        html += `<li>${rec}</li>`;
      });
      html += '</ul>';
    }

    html += '</div>';
    return html;
  }

  /**
   * Generate text version
   */
  private generateTextVersion(summary: any): string {
    let text = '';

    if (summary.overview) {
      text += `SUMMARY\n${summary.overview}\n\n`;
    }

    if (summary.keyMetrics) {
      text += 'KEY METRICS\n';
      summary.keyMetrics.forEach((metric: any) => {
        text += `${metric.label}: ${metric.value}\n`;
      });
      text += '\n';
    }

    if (summary.recommendations) {
      text += 'RECOMMENDATIONS\n';
      summary.recommendations.forEach((rec: string) => {
        text += `- ${rec}\n`;
      });
    }

    return text;
  }

  /**
   * Wrap HTML in email template
   */
  private wrapInEmailTemplate(content: string): string {
    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Real Estate Summary</title>
</head>
<body style="margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #f4f4f4;">
  <div style="max-width: 800px; margin: 20px auto; background-color: #ffffff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
    ${content}
    <hr style="margin: 20px 0; border: none; border-top: 1px solid #e0e0e0;">
    <p style="color: #666; font-size: 12px; text-align: center;">
      Generated by Real Estate Analyzer
    </p>
  </div>
</body>
</html>
    `.trim();
  }

  /**
   * Generate email subject
   */
  private generateSubject(summary: any): string {
    const type = summary.type || 'Summary';
    const period = summary.period
      ? `${summary.period.start.toLocaleDateString()} - ${summary.period.end.toLocaleDateString()}`
      : new Date().toLocaleDateString();

    return `${type.charAt(0).toUpperCase() + type.slice(1)} Report - ${period}`;
  }

  /**
   * Send email (requires nodemailer)
   */
  async sendEmail(emailReport: EmailReport): Promise<void> {
    try {
      // Try to use nodemailer if available
      let nodemailer: any;
      try {
        // Use eval to prevent webpack from trying to bundle nodemailer at build time
        // eslint-disable-next-line @typescript-eslint/no-implied-eval
        nodemailer = new Function('return require("nodemailer")')();
      } catch {
        this.logger.warn(
          'nodemailer not installed. Install it with: npm install nodemailer @types/nodemailer',
          'EmailFormatterService'
        );
        this.logger.log(
          `Email would be sent to: ${emailReport.to.join(', ')}`,
          'EmailFormatterService'
        );
        return;
      }

      const env = this.configService.get<string>('NODE_ENV', 'development');
      const smtpHost = this.configService.get<string>('SMTP_HOST');
      const smtpPort = this.configService.get<number>('SMTP_PORT', 587);
      const smtpUser = this.configService.get<string>('SMTP_USER');
      const smtpPass = this.configService.get<string>('SMTP_PASS');
      const smtpFrom = this.configService.get<string>('SMTP_FROM', 'noreply@real-estate-analyzer.com');

      // In development, use console transport or test account
      if (env === 'development' || env === 'local') {
        // Option 1: Use console transport for dev (logs to console)
      const transporter = nodemailer.createTransport({
        jsonTransport: true, // Returns email as JSON string
      });

        const result = await transporter.sendMail({
          from: smtpFrom,
          to: emailReport.to.join(', '),
          cc: emailReport.cc?.join(', '),
          bcc: emailReport.bcc?.join(', '),
          subject: emailReport.subject,
          html: emailReport.html,
          text: emailReport.text,
          attachments: emailReport.attachments,
        });

        this.logger.logWithMetadata(
          'info',
          `Email sent (dev mode - JSON transport)`,
          {
            recipients: emailReport.to,
            subject: emailReport.subject,
            emailJson: result.message,
          },
          'EmailFormatterService'
        );
        return;
      }

      // Production: Use actual SMTP
      if (!smtpHost || !smtpUser || !smtpPass) {
        throw new Error('SMTP configuration missing. Set SMTP_HOST, SMTP_USER, and SMTP_PASS environment variables.');
      }

      const transporter = nodemailer.createTransport({
        host: smtpHost,
        port: smtpPort,
        secure: smtpPort === 465, // true for 465, false for other ports
        auth: {
          user: smtpUser,
          pass: smtpPass,
        },
      });

      const info = await transporter.sendMail({
        from: smtpFrom,
        to: emailReport.to.join(', '),
        cc: emailReport.cc?.join(', '),
        bcc: emailReport.bcc?.join(', '),
        subject: emailReport.subject,
        html: emailReport.html,
        text: emailReport.text,
        attachments: emailReport.attachments,
      });

      this.logger.logWithMetadata(
        'info',
        `Email sent successfully`,
        {
          recipients: emailReport.to,
          subject: emailReport.subject,
          messageId: info.messageId,
        },
        'EmailFormatterService'
      );
    } catch (error) {
      this.logger.error(
        `Failed to send email: ${error instanceof Error ? error.message : 'Unknown error'}`,
        error instanceof Error ? error.stack : undefined,
        'EmailFormatterService',
        {
          recipients: emailReport.to,
          subject: emailReport.subject,
        }
      );
      throw error;
    }
  }
}

